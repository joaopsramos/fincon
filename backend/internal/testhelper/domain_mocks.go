// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package testhelper

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/joaopsramos/fincon/internal/domain"
	mock "github.com/stretchr/testify/mock"
)

// NewMockExpenseRepo creates a new instance of MockExpenseRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockExpenseRepo(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockExpenseRepo {
	mock := &MockExpenseRepo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockExpenseRepo is an autogenerated mock type for the ExpenseRepo type
type MockExpenseRepo struct {
	mock.Mock
}

type MockExpenseRepo_Expecter struct {
	mock *mock.Mock
}

func (_m *MockExpenseRepo) EXPECT() *MockExpenseRepo_Expecter {
	return &MockExpenseRepo_Expecter{mock: &_m.Mock}
}

// AllByGoalID provides a mock function for the type MockExpenseRepo
func (_mock *MockExpenseRepo) AllByGoalID(ctx context.Context, goalID uint, year int, month time.Month, userID uuid.UUID) ([]domain.Expense, error) {
	ret := _mock.Called(ctx, goalID, year, month, userID)

	if len(ret) == 0 {
		panic("no return value specified for AllByGoalID")
	}

	var r0 []domain.Expense
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint, int, time.Month, uuid.UUID) ([]domain.Expense, error)); ok {
		return returnFunc(ctx, goalID, year, month, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint, int, time.Month, uuid.UUID) []domain.Expense); ok {
		r0 = returnFunc(ctx, goalID, year, month, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Expense)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint, int, time.Month, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, goalID, year, month, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockExpenseRepo_AllByGoalID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllByGoalID'
type MockExpenseRepo_AllByGoalID_Call struct {
	*mock.Call
}

// AllByGoalID is a helper method to define mock.On call
//   - ctx
//   - goalID
//   - year
//   - month
//   - userID
func (_e *MockExpenseRepo_Expecter) AllByGoalID(ctx interface{}, goalID interface{}, year interface{}, month interface{}, userID interface{}) *MockExpenseRepo_AllByGoalID_Call {
	return &MockExpenseRepo_AllByGoalID_Call{Call: _e.mock.On("AllByGoalID", ctx, goalID, year, month, userID)}
}

func (_c *MockExpenseRepo_AllByGoalID_Call) Run(run func(ctx context.Context, goalID uint, year int, month time.Month, userID uuid.UUID)) *MockExpenseRepo_AllByGoalID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(int), args[3].(time.Month), args[4].(uuid.UUID))
	})
	return _c
}

func (_c *MockExpenseRepo_AllByGoalID_Call) Return(expenses []domain.Expense, err error) *MockExpenseRepo_AllByGoalID_Call {
	_c.Call.Return(expenses, err)
	return _c
}

func (_c *MockExpenseRepo_AllByGoalID_Call) RunAndReturn(run func(ctx context.Context, goalID uint, year int, month time.Month, userID uuid.UUID) ([]domain.Expense, error)) *MockExpenseRepo_AllByGoalID_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockExpenseRepo
func (_mock *MockExpenseRepo) Create(ctx context.Context, e *domain.Expense) error {
	ret := _mock.Called(ctx, e)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Expense) error); ok {
		r0 = returnFunc(ctx, e)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockExpenseRepo_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockExpenseRepo_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx
//   - e
func (_e *MockExpenseRepo_Expecter) Create(ctx interface{}, e interface{}) *MockExpenseRepo_Create_Call {
	return &MockExpenseRepo_Create_Call{Call: _e.mock.On("Create", ctx, e)}
}

func (_c *MockExpenseRepo_Create_Call) Run(run func(ctx context.Context, e *domain.Expense)) *MockExpenseRepo_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.Expense))
	})
	return _c
}

func (_c *MockExpenseRepo_Create_Call) Return(err error) *MockExpenseRepo_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockExpenseRepo_Create_Call) RunAndReturn(run func(ctx context.Context, e *domain.Expense) error) *MockExpenseRepo_Create_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMany provides a mock function for the type MockExpenseRepo
func (_mock *MockExpenseRepo) CreateMany(ctx context.Context, e []domain.Expense) error {
	ret := _mock.Called(ctx, e)

	if len(ret) == 0 {
		panic("no return value specified for CreateMany")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []domain.Expense) error); ok {
		r0 = returnFunc(ctx, e)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockExpenseRepo_CreateMany_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMany'
type MockExpenseRepo_CreateMany_Call struct {
	*mock.Call
}

// CreateMany is a helper method to define mock.On call
//   - ctx
//   - e
func (_e *MockExpenseRepo_Expecter) CreateMany(ctx interface{}, e interface{}) *MockExpenseRepo_CreateMany_Call {
	return &MockExpenseRepo_CreateMany_Call{Call: _e.mock.On("CreateMany", ctx, e)}
}

func (_c *MockExpenseRepo_CreateMany_Call) Run(run func(ctx context.Context, e []domain.Expense)) *MockExpenseRepo_CreateMany_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]domain.Expense))
	})
	return _c
}

func (_c *MockExpenseRepo_CreateMany_Call) Return(err error) *MockExpenseRepo_CreateMany_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockExpenseRepo_CreateMany_Call) RunAndReturn(run func(ctx context.Context, e []domain.Expense) error) *MockExpenseRepo_CreateMany_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockExpenseRepo
func (_mock *MockExpenseRepo) Delete(ctx context.Context, id uint, userID uuid.UUID) error {
	ret := _mock.Called(ctx, id, userID)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, id, userID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockExpenseRepo_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockExpenseRepo_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx
//   - id
//   - userID
func (_e *MockExpenseRepo_Expecter) Delete(ctx interface{}, id interface{}, userID interface{}) *MockExpenseRepo_Delete_Call {
	return &MockExpenseRepo_Delete_Call{Call: _e.mock.On("Delete", ctx, id, userID)}
}

func (_c *MockExpenseRepo_Delete_Call) Run(run func(ctx context.Context, id uint, userID uuid.UUID)) *MockExpenseRepo_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *MockExpenseRepo_Delete_Call) Return(err error) *MockExpenseRepo_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockExpenseRepo_Delete_Call) RunAndReturn(run func(ctx context.Context, id uint, userID uuid.UUID) error) *MockExpenseRepo_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// FindMatchingNames provides a mock function for the type MockExpenseRepo
func (_mock *MockExpenseRepo) FindMatchingNames(ctx context.Context, name string, userID uuid.UUID) ([]string, error) {
	ret := _mock.Called(ctx, name, userID)

	if len(ret) == 0 {
		panic("no return value specified for FindMatchingNames")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, uuid.UUID) ([]string, error)); ok {
		return returnFunc(ctx, name, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, uuid.UUID) []string); ok {
		r0 = returnFunc(ctx, name, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, name, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockExpenseRepo_FindMatchingNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindMatchingNames'
type MockExpenseRepo_FindMatchingNames_Call struct {
	*mock.Call
}

// FindMatchingNames is a helper method to define mock.On call
//   - ctx
//   - name
//   - userID
func (_e *MockExpenseRepo_Expecter) FindMatchingNames(ctx interface{}, name interface{}, userID interface{}) *MockExpenseRepo_FindMatchingNames_Call {
	return &MockExpenseRepo_FindMatchingNames_Call{Call: _e.mock.On("FindMatchingNames", ctx, name, userID)}
}

func (_c *MockExpenseRepo_FindMatchingNames_Call) Run(run func(ctx context.Context, name string, userID uuid.UUID)) *MockExpenseRepo_FindMatchingNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *MockExpenseRepo_FindMatchingNames_Call) Return(strings []string, err error) *MockExpenseRepo_FindMatchingNames_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *MockExpenseRepo_FindMatchingNames_Call) RunAndReturn(run func(ctx context.Context, name string, userID uuid.UUID) ([]string, error)) *MockExpenseRepo_FindMatchingNames_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockExpenseRepo
func (_mock *MockExpenseRepo) Get(ctx context.Context, id uint, userID uuid.UUID) (*domain.Expense, error) {
	ret := _mock.Called(ctx, id, userID)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *domain.Expense
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint, uuid.UUID) (*domain.Expense, error)); ok {
		return returnFunc(ctx, id, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint, uuid.UUID) *domain.Expense); ok {
		r0 = returnFunc(ctx, id, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Expense)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockExpenseRepo_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockExpenseRepo_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx
//   - id
//   - userID
func (_e *MockExpenseRepo_Expecter) Get(ctx interface{}, id interface{}, userID interface{}) *MockExpenseRepo_Get_Call {
	return &MockExpenseRepo_Get_Call{Call: _e.mock.On("Get", ctx, id, userID)}
}

func (_c *MockExpenseRepo_Get_Call) Run(run func(ctx context.Context, id uint, userID uuid.UUID)) *MockExpenseRepo_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *MockExpenseRepo_Get_Call) Return(expense *domain.Expense, err error) *MockExpenseRepo_Get_Call {
	_c.Call.Return(expense, err)
	return _c
}

func (_c *MockExpenseRepo_Get_Call) RunAndReturn(run func(ctx context.Context, id uint, userID uuid.UUID) (*domain.Expense, error)) *MockExpenseRepo_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetMonthlyGoalSpendings provides a mock function for the type MockExpenseRepo
func (_mock *MockExpenseRepo) GetMonthlyGoalSpendings(ctx context.Context, date time.Time, userID uuid.UUID) ([]domain.MonthlyGoalSpending, error) {
	ret := _mock.Called(ctx, date, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetMonthlyGoalSpendings")
	}

	var r0 []domain.MonthlyGoalSpending
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Time, uuid.UUID) ([]domain.MonthlyGoalSpending, error)); ok {
		return returnFunc(ctx, date, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Time, uuid.UUID) []domain.MonthlyGoalSpending); ok {
		r0 = returnFunc(ctx, date, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.MonthlyGoalSpending)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, time.Time, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, date, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockExpenseRepo_GetMonthlyGoalSpendings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMonthlyGoalSpendings'
type MockExpenseRepo_GetMonthlyGoalSpendings_Call struct {
	*mock.Call
}

// GetMonthlyGoalSpendings is a helper method to define mock.On call
//   - ctx
//   - date
//   - userID
func (_e *MockExpenseRepo_Expecter) GetMonthlyGoalSpendings(ctx interface{}, date interface{}, userID interface{}) *MockExpenseRepo_GetMonthlyGoalSpendings_Call {
	return &MockExpenseRepo_GetMonthlyGoalSpendings_Call{Call: _e.mock.On("GetMonthlyGoalSpendings", ctx, date, userID)}
}

func (_c *MockExpenseRepo_GetMonthlyGoalSpendings_Call) Run(run func(ctx context.Context, date time.Time, userID uuid.UUID)) *MockExpenseRepo_GetMonthlyGoalSpendings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Time), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *MockExpenseRepo_GetMonthlyGoalSpendings_Call) Return(monthlyGoalSpendings []domain.MonthlyGoalSpending, err error) *MockExpenseRepo_GetMonthlyGoalSpendings_Call {
	_c.Call.Return(monthlyGoalSpendings, err)
	return _c
}

func (_c *MockExpenseRepo_GetMonthlyGoalSpendings_Call) RunAndReturn(run func(ctx context.Context, date time.Time, userID uuid.UUID) ([]domain.MonthlyGoalSpending, error)) *MockExpenseRepo_GetMonthlyGoalSpendings_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockExpenseRepo
func (_mock *MockExpenseRepo) Update(ctx context.Context, e *domain.Expense) error {
	ret := _mock.Called(ctx, e)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Expense) error); ok {
		r0 = returnFunc(ctx, e)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockExpenseRepo_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockExpenseRepo_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx
//   - e
func (_e *MockExpenseRepo_Expecter) Update(ctx interface{}, e interface{}) *MockExpenseRepo_Update_Call {
	return &MockExpenseRepo_Update_Call{Call: _e.mock.On("Update", ctx, e)}
}

func (_c *MockExpenseRepo_Update_Call) Run(run func(ctx context.Context, e *domain.Expense)) *MockExpenseRepo_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.Expense))
	})
	return _c
}

func (_c *MockExpenseRepo_Update_Call) Return(err error) *MockExpenseRepo_Update_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockExpenseRepo_Update_Call) RunAndReturn(run func(ctx context.Context, e *domain.Expense) error) *MockExpenseRepo_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGoalRepo creates a new instance of MockGoalRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGoalRepo(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGoalRepo {
	mock := &MockGoalRepo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockGoalRepo is an autogenerated mock type for the GoalRepo type
type MockGoalRepo struct {
	mock.Mock
}

type MockGoalRepo_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGoalRepo) EXPECT() *MockGoalRepo_Expecter {
	return &MockGoalRepo_Expecter{mock: &_m.Mock}
}

// All provides a mock function for the type MockGoalRepo
func (_mock *MockGoalRepo) All(ctx context.Context, userID uuid.UUID) []domain.Goal {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for All")
	}

	var r0 []domain.Goal
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) []domain.Goal); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Goal)
		}
	}
	return r0
}

// MockGoalRepo_All_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'All'
type MockGoalRepo_All_Call struct {
	*mock.Call
}

// All is a helper method to define mock.On call
//   - ctx
//   - userID
func (_e *MockGoalRepo_Expecter) All(ctx interface{}, userID interface{}) *MockGoalRepo_All_Call {
	return &MockGoalRepo_All_Call{Call: _e.mock.On("All", ctx, userID)}
}

func (_c *MockGoalRepo_All_Call) Run(run func(ctx context.Context, userID uuid.UUID)) *MockGoalRepo_All_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockGoalRepo_All_Call) Return(goals []domain.Goal) *MockGoalRepo_All_Call {
	_c.Call.Return(goals)
	return _c
}

func (_c *MockGoalRepo_All_Call) RunAndReturn(run func(ctx context.Context, userID uuid.UUID) []domain.Goal) *MockGoalRepo_All_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockGoalRepo
func (_mock *MockGoalRepo) Create(ctx context.Context, goals ...domain.Goal) error {
	var tmpRet mock.Arguments
	if len(goals) > 0 {
		tmpRet = _mock.Called(ctx, goals)
	} else {
		tmpRet = _mock.Called(ctx)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...domain.Goal) error); ok {
		r0 = returnFunc(ctx, goals...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockGoalRepo_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockGoalRepo_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx
//   - goals
func (_e *MockGoalRepo_Expecter) Create(ctx interface{}, goals ...interface{}) *MockGoalRepo_Create_Call {
	return &MockGoalRepo_Create_Call{Call: _e.mock.On("Create",
		append([]interface{}{ctx}, goals...)...)}
}

func (_c *MockGoalRepo_Create_Call) Run(run func(ctx context.Context, goals ...domain.Goal)) *MockGoalRepo_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[1].([]domain.Goal)
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockGoalRepo_Create_Call) Return(err error) *MockGoalRepo_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockGoalRepo_Create_Call) RunAndReturn(run func(ctx context.Context, goals ...domain.Goal) error) *MockGoalRepo_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockGoalRepo
func (_mock *MockGoalRepo) Get(ctx context.Context, id uint, userID uuid.UUID) (*domain.Goal, error) {
	ret := _mock.Called(ctx, id, userID)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *domain.Goal
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint, uuid.UUID) (*domain.Goal, error)); ok {
		return returnFunc(ctx, id, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint, uuid.UUID) *domain.Goal); ok {
		r0 = returnFunc(ctx, id, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Goal)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockGoalRepo_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockGoalRepo_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx
//   - id
//   - userID
func (_e *MockGoalRepo_Expecter) Get(ctx interface{}, id interface{}, userID interface{}) *MockGoalRepo_Get_Call {
	return &MockGoalRepo_Get_Call{Call: _e.mock.On("Get", ctx, id, userID)}
}

func (_c *MockGoalRepo_Get_Call) Run(run func(ctx context.Context, id uint, userID uuid.UUID)) *MockGoalRepo_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *MockGoalRepo_Get_Call) Return(goal *domain.Goal, err error) *MockGoalRepo_Get_Call {
	_c.Call.Return(goal, err)
	return _c
}

func (_c *MockGoalRepo_Get_Call) RunAndReturn(run func(ctx context.Context, id uint, userID uuid.UUID) (*domain.Goal, error)) *MockGoalRepo_Get_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAll provides a mock function for the type MockGoalRepo
func (_mock *MockGoalRepo) UpdateAll(ctx context.Context, goals []domain.Goal) error {
	ret := _mock.Called(ctx, goals)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAll")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []domain.Goal) error); ok {
		r0 = returnFunc(ctx, goals)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockGoalRepo_UpdateAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAll'
type MockGoalRepo_UpdateAll_Call struct {
	*mock.Call
}

// UpdateAll is a helper method to define mock.On call
//   - ctx
//   - goals
func (_e *MockGoalRepo_Expecter) UpdateAll(ctx interface{}, goals interface{}) *MockGoalRepo_UpdateAll_Call {
	return &MockGoalRepo_UpdateAll_Call{Call: _e.mock.On("UpdateAll", ctx, goals)}
}

func (_c *MockGoalRepo_UpdateAll_Call) Run(run func(ctx context.Context, goals []domain.Goal)) *MockGoalRepo_UpdateAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]domain.Goal))
	})
	return _c
}

func (_c *MockGoalRepo_UpdateAll_Call) Return(err error) *MockGoalRepo_UpdateAll_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockGoalRepo_UpdateAll_Call) RunAndReturn(run func(ctx context.Context, goals []domain.Goal) error) *MockGoalRepo_UpdateAll_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSalaryRepo creates a new instance of MockSalaryRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSalaryRepo(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSalaryRepo {
	mock := &MockSalaryRepo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSalaryRepo is an autogenerated mock type for the SalaryRepo type
type MockSalaryRepo struct {
	mock.Mock
}

type MockSalaryRepo_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSalaryRepo) EXPECT() *MockSalaryRepo_Expecter {
	return &MockSalaryRepo_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockSalaryRepo
func (_mock *MockSalaryRepo) Create(ctx context.Context, salary *domain.Salary) error {
	ret := _mock.Called(ctx, salary)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Salary) error); ok {
		r0 = returnFunc(ctx, salary)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockSalaryRepo_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockSalaryRepo_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx
//   - salary
func (_e *MockSalaryRepo_Expecter) Create(ctx interface{}, salary interface{}) *MockSalaryRepo_Create_Call {
	return &MockSalaryRepo_Create_Call{Call: _e.mock.On("Create", ctx, salary)}
}

func (_c *MockSalaryRepo_Create_Call) Run(run func(ctx context.Context, salary *domain.Salary)) *MockSalaryRepo_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.Salary))
	})
	return _c
}

func (_c *MockSalaryRepo_Create_Call) Return(err error) *MockSalaryRepo_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockSalaryRepo_Create_Call) RunAndReturn(run func(ctx context.Context, salary *domain.Salary) error) *MockSalaryRepo_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockSalaryRepo
func (_mock *MockSalaryRepo) Get(ctx context.Context, userID uuid.UUID) (*domain.Salary, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *domain.Salary
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*domain.Salary, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *domain.Salary); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Salary)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSalaryRepo_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockSalaryRepo_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx
//   - userID
func (_e *MockSalaryRepo_Expecter) Get(ctx interface{}, userID interface{}) *MockSalaryRepo_Get_Call {
	return &MockSalaryRepo_Get_Call{Call: _e.mock.On("Get", ctx, userID)}
}

func (_c *MockSalaryRepo_Get_Call) Run(run func(ctx context.Context, userID uuid.UUID)) *MockSalaryRepo_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockSalaryRepo_Get_Call) Return(salary *domain.Salary, err error) *MockSalaryRepo_Get_Call {
	_c.Call.Return(salary, err)
	return _c
}

func (_c *MockSalaryRepo_Get_Call) RunAndReturn(run func(ctx context.Context, userID uuid.UUID) (*domain.Salary, error)) *MockSalaryRepo_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockSalaryRepo
func (_mock *MockSalaryRepo) Update(ctx context.Context, salary *domain.Salary) error {
	ret := _mock.Called(ctx, salary)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Salary) error); ok {
		r0 = returnFunc(ctx, salary)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockSalaryRepo_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockSalaryRepo_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx
//   - salary
func (_e *MockSalaryRepo_Expecter) Update(ctx interface{}, salary interface{}) *MockSalaryRepo_Update_Call {
	return &MockSalaryRepo_Update_Call{Call: _e.mock.On("Update", ctx, salary)}
}

func (_c *MockSalaryRepo_Update_Call) Run(run func(ctx context.Context, salary *domain.Salary)) *MockSalaryRepo_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.Salary))
	})
	return _c
}

func (_c *MockSalaryRepo_Update_Call) Return(err error) *MockSalaryRepo_Update_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockSalaryRepo_Update_Call) RunAndReturn(run func(ctx context.Context, salary *domain.Salary) error) *MockSalaryRepo_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserRepo creates a new instance of MockUserRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserRepo(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserRepo {
	mock := &MockUserRepo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUserRepo is an autogenerated mock type for the UserRepo type
type MockUserRepo struct {
	mock.Mock
}

type MockUserRepo_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserRepo) EXPECT() *MockUserRepo_Expecter {
	return &MockUserRepo_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockUserRepo
func (_mock *MockUserRepo) Create(ctx context.Context, user *domain.User, salary *domain.Salary) error {
	ret := _mock.Called(ctx, user, salary)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.User, *domain.Salary) error); ok {
		r0 = returnFunc(ctx, user, salary)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUserRepo_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockUserRepo_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx
//   - user
//   - salary
func (_e *MockUserRepo_Expecter) Create(ctx interface{}, user interface{}, salary interface{}) *MockUserRepo_Create_Call {
	return &MockUserRepo_Create_Call{Call: _e.mock.On("Create", ctx, user, salary)}
}

func (_c *MockUserRepo_Create_Call) Run(run func(ctx context.Context, user *domain.User, salary *domain.Salary)) *MockUserRepo_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.User), args[2].(*domain.Salary))
	})
	return _c
}

func (_c *MockUserRepo_Create_Call) Return(err error) *MockUserRepo_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUserRepo_Create_Call) RunAndReturn(run func(ctx context.Context, user *domain.User, salary *domain.Salary) error) *MockUserRepo_Create_Call {
	_c.Call.Return(run)
	return _c
}

// CreateToken provides a mock function for the type MockUserRepo
func (_mock *MockUserRepo) CreateToken(ctx context.Context, token *domain.UserToken) error {
	ret := _mock.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for CreateToken")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.UserToken) error); ok {
		r0 = returnFunc(ctx, token)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUserRepo_CreateToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateToken'
type MockUserRepo_CreateToken_Call struct {
	*mock.Call
}

// CreateToken is a helper method to define mock.On call
//   - ctx
//   - token
func (_e *MockUserRepo_Expecter) CreateToken(ctx interface{}, token interface{}) *MockUserRepo_CreateToken_Call {
	return &MockUserRepo_CreateToken_Call{Call: _e.mock.On("CreateToken", ctx, token)}
}

func (_c *MockUserRepo_CreateToken_Call) Run(run func(ctx context.Context, token *domain.UserToken)) *MockUserRepo_CreateToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.UserToken))
	})
	return _c
}

func (_c *MockUserRepo_CreateToken_Call) Return(err error) *MockUserRepo_CreateToken_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUserRepo_CreateToken_Call) RunAndReturn(run func(ctx context.Context, token *domain.UserToken) error) *MockUserRepo_CreateToken_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockUserRepo
func (_mock *MockUserRepo) Get(ctx context.Context, id uuid.UUID) (*domain.User, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *domain.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*domain.User, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *domain.User); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepo_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockUserRepo_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *MockUserRepo_Expecter) Get(ctx interface{}, id interface{}) *MockUserRepo_Get_Call {
	return &MockUserRepo_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockUserRepo_Get_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockUserRepo_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockUserRepo_Get_Call) Return(user *domain.User, err error) *MockUserRepo_Get_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockUserRepo_Get_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*domain.User, error)) *MockUserRepo_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetByEmail provides a mock function for the type MockUserRepo
func (_mock *MockUserRepo) GetByEmail(ctx context.Context, email string) (*domain.User, error) {
	ret := _mock.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetByEmail")
	}

	var r0 *domain.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*domain.User, error)); ok {
		return returnFunc(ctx, email)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *domain.User); ok {
		r0 = returnFunc(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, email)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepo_GetByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByEmail'
type MockUserRepo_GetByEmail_Call struct {
	*mock.Call
}

// GetByEmail is a helper method to define mock.On call
//   - ctx
//   - email
func (_e *MockUserRepo_Expecter) GetByEmail(ctx interface{}, email interface{}) *MockUserRepo_GetByEmail_Call {
	return &MockUserRepo_GetByEmail_Call{Call: _e.mock.On("GetByEmail", ctx, email)}
}

func (_c *MockUserRepo_GetByEmail_Call) Run(run func(ctx context.Context, email string)) *MockUserRepo_GetByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUserRepo_GetByEmail_Call) Return(user *domain.User, err error) *MockUserRepo_GetByEmail_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockUserRepo_GetByEmail_Call) RunAndReturn(run func(ctx context.Context, email string) (*domain.User, error)) *MockUserRepo_GetByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserTokenByToken provides a mock function for the type MockUserRepo
func (_mock *MockUserRepo) GetUserTokenByToken(ctx context.Context, token string) (*domain.UserToken, error) {
	ret := _mock.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for GetUserTokenByToken")
	}

	var r0 *domain.UserToken
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*domain.UserToken, error)); ok {
		return returnFunc(ctx, token)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *domain.UserToken); ok {
		r0 = returnFunc(ctx, token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.UserToken)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, token)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepo_GetUserTokenByToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserTokenByToken'
type MockUserRepo_GetUserTokenByToken_Call struct {
	*mock.Call
}

// GetUserTokenByToken is a helper method to define mock.On call
//   - ctx
//   - token
func (_e *MockUserRepo_Expecter) GetUserTokenByToken(ctx interface{}, token interface{}) *MockUserRepo_GetUserTokenByToken_Call {
	return &MockUserRepo_GetUserTokenByToken_Call{Call: _e.mock.On("GetUserTokenByToken", ctx, token)}
}

func (_c *MockUserRepo_GetUserTokenByToken_Call) Run(run func(ctx context.Context, token string)) *MockUserRepo_GetUserTokenByToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUserRepo_GetUserTokenByToken_Call) Return(userToken *domain.UserToken, err error) *MockUserRepo_GetUserTokenByToken_Call {
	_c.Call.Return(userToken, err)
	return _c
}

func (_c *MockUserRepo_GetUserTokenByToken_Call) RunAndReturn(run func(ctx context.Context, token string) (*domain.UserToken, error)) *MockUserRepo_GetUserTokenByToken_Call {
	_c.Call.Return(run)
	return _c
}

// MarkTokenAsUsed provides a mock function for the type MockUserRepo
func (_mock *MockUserRepo) MarkTokenAsUsed(ctx context.Context, tokenID uint) error {
	ret := _mock.Called(ctx, tokenID)

	if len(ret) == 0 {
		panic("no return value specified for MarkTokenAsUsed")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint) error); ok {
		r0 = returnFunc(ctx, tokenID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUserRepo_MarkTokenAsUsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkTokenAsUsed'
type MockUserRepo_MarkTokenAsUsed_Call struct {
	*mock.Call
}

// MarkTokenAsUsed is a helper method to define mock.On call
//   - ctx
//   - tokenID
func (_e *MockUserRepo_Expecter) MarkTokenAsUsed(ctx interface{}, tokenID interface{}) *MockUserRepo_MarkTokenAsUsed_Call {
	return &MockUserRepo_MarkTokenAsUsed_Call{Call: _e.mock.On("MarkTokenAsUsed", ctx, tokenID)}
}

func (_c *MockUserRepo_MarkTokenAsUsed_Call) Run(run func(ctx context.Context, tokenID uint)) *MockUserRepo_MarkTokenAsUsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint))
	})
	return _c
}

func (_c *MockUserRepo_MarkTokenAsUsed_Call) Return(err error) *MockUserRepo_MarkTokenAsUsed_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUserRepo_MarkTokenAsUsed_Call) RunAndReturn(run func(ctx context.Context, tokenID uint) error) *MockUserRepo_MarkTokenAsUsed_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUserPassword provides a mock function for the type MockUserRepo
func (_mock *MockUserRepo) UpdateUserPassword(ctx context.Context, userID uuid.UUID, hashedPassword string) error {
	ret := _mock.Called(ctx, userID, hashedPassword)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserPassword")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, string) error); ok {
		r0 = returnFunc(ctx, userID, hashedPassword)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUserRepo_UpdateUserPassword_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUserPassword'
type MockUserRepo_UpdateUserPassword_Call struct {
	*mock.Call
}

// UpdateUserPassword is a helper method to define mock.On call
//   - ctx
//   - userID
//   - hashedPassword
func (_e *MockUserRepo_Expecter) UpdateUserPassword(ctx interface{}, userID interface{}, hashedPassword interface{}) *MockUserRepo_UpdateUserPassword_Call {
	return &MockUserRepo_UpdateUserPassword_Call{Call: _e.mock.On("UpdateUserPassword", ctx, userID, hashedPassword)}
}

func (_c *MockUserRepo_UpdateUserPassword_Call) Run(run func(ctx context.Context, userID uuid.UUID, hashedPassword string)) *MockUserRepo_UpdateUserPassword_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string))
	})
	return _c
}

func (_c *MockUserRepo_UpdateUserPassword_Call) Return(err error) *MockUserRepo_UpdateUserPassword_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUserRepo_UpdateUserPassword_Call) RunAndReturn(run func(ctx context.Context, userID uuid.UUID, hashedPassword string) error) *MockUserRepo_UpdateUserPassword_Call {
	_c.Call.Return(run)
	return _c
}
